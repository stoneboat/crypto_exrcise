## 指令流水线仿真程序
## 1410657 卫煜
## 实验内容
### NK-CPU 指令流水线仿真的基本数据结构
+   五流水段 IF,ID,EX,MEM,WB 用五个线程模拟
+   实现了线程安全的集合flyingReg保存没有经过写回流水段的指令的结果寄存器
+   段寄存器如下，其中段指令寄存器保存指令内容和指令编号
+   <br>
![](segmentRegFile.png)
+   内存存储采用哈弗结构，指令内存和数据内存分开
+   时钟控制信号由 主线程控制向流水段发送，每个时钟周期分为上半周期和下半周期。由于软件模拟的问题每个线程的运行受操作系统的影响，不可能控制线程在一定时间内完成即使是很少量的工作所以采用唤醒和等待的机制
### 软件运行组件 
+   由于c++线程类库行为太过不可理喻，使用boost线程类库实现本实验。使用vs包管理器nuget下载boost的头文件包，然后根据本实验源文件引用的头文件下载相应vs版本的编译二进制库文件。我在实验中直接下载了boost完整代码一共6g左右，太过庞大所以不作为源文件上传了。
### 软件的运行和bug
+   软件的运行需要先载入机器码，然后可以选择单步运行或者运行，但是运行选项在生成的exe文件中使用可能会卡死，但是如果直接使用调试功能编译则没有问题，我录制了视频展示排序程序的过程希望能够弥补这个过失。 
+   数据内存在启用数据内存修改后可修改，但是有时候点击一次功能并不会响应，如果出现这种情况请多点击一次尝试，我不知道mfc因为什么没有修改响应变量虽然确实执行了响应函数
+   流水cpu演示文件.mp4 对软件做了展示

## 实验设计依据
### 实验的实现细节
+   每个流水段继承自同一个线程类，该线程类分为四个行为（虚函数），两个半个周期：取前预处理，取操作，存操作，存后处理。其中取操作为从段寄存器文件中读取数据，进行段内行为。存操作是将操作结果写回段寄存器文件。由于对段寄存器文件的操作分别在两个半周期中只读，只写不会造成读写冲突。取前和存后则是对数据冒险和分支冒险的处理，之所以要与前之区分也是为了防止读写冲突。
#### 流水段的冒险
+   对于分支冒险。IF实现了预取处理来对分支冒险进行处理，直接读取转移判断和分支操作码来判断是否需要阻塞ID，EX段的操作。
+   对于数据冒险。ID段通过判断源寄存器是否在flyingReg中来决定是否阻塞该条指令。WB将指令的源操作寄存器从flyingReg中移除。
+   对于资源冒险。用哈弗结构完成了资源冒险的避免。数据内存的读写冲突在简单五段流水线中通过对内存先写后读进行了避免。
## 实验结果与分析
排序前<br>
![](disp1.png)<br>
单步执行遇到数据冒险<br>
![](disp3.png)<br>
排序后<br>
![](disp2.png)<br>
演示文件
流水cpu演示文件.mp4
## 实验心得
+   由于第一次编写并行程序，觉得对流水线的实现不是很好，有bug的存在。因为修改起来十分吃力，没有实现非阻塞式的冒险解决方案，比如分支冒险的延迟槽操作（这个需要在编译机器码时做修改），数据冒险的旁通，下次实验应该统一解决